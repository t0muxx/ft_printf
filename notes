%% permet d'escape le % et donc de lafficher.

Flag "#" : Utiliser la forme alternative.
	Avec le convert %o/%O Le premier char de la chaine est 0.
	Avec le convert %x/%X la chaine commence par 0x/0X

Flag "0X" : Avec un convertion numerique, rempli le nombre de 0 a gauche suivant le nombre de digit manquant
		 : Il peut etre utilise en combinaison avec #

Flag "-X" : Ecris le nombre sur X digit et ajoute des espace a droite si besoin.
Lattrivu surchage le 0

Flag " " (espace) : Laisse un espace pour les nombre positif et affiche le - pour les negatifs.

Flag "+" : force le signe "+" pour les nombre positif

si juste un nombre, c'est la taille minimal du champ on ajoute X espace a gauche
Si la taille minimal du champ est negativ on considere ca comme loptiobn -

La precision ".X" : Pour les conversion de entier, indique le nombre minimum de chiffre a faire apparaitre.
Pour un conversion "%s"/"%S" : le nombre maximum de char a afficher.

modificateur :

flag "hh" : La prochaine convertion correspond a un signed ou unsigned char ou si c'est un un
n qui suit correspond a un pointer sur signed char (agit comme un cast)

flag "h" : meme chose qu' aux dessus mais pour un short int/unsigned short int

flag "l" : correspond a un cast de long int; si c'est pour s, correspond a un wchar_t*

flag "ll" correspond a un cast long long int

flag "j" : cast la prochaine conversion en intmax_t/uintmax_t

flag : "z" : cast en size_t;

Conversion "s"/"S" : Convertit en chaine de char, ou avec grand S en tableau de wchar_t
Conversion "p" 	 : the void * pointer argument is printed in hexadecimal (as if by %#x or %#lx).
Conversion "c" : If no l modifier is present, the int argument is converted to
              an unsigned char, and the resulting character is written.  If
              an l modifier is present, the wint_t (wide character) argument
              is converted to a multibyte sequence by a call to the
              wcrtomb(3) function, with a conversion state starting in the
              initial state, and the resulting multibyte string is written.
Convertion "o"/"O" : converti un unsigned int en unsigned octal
Convertion "x"/"X" : converti un unsigned int en en unsigned hexa (x : abcdef | X : ABCDEF)
Convertion "d", "i" : converti un int en decimal avec signe, la precision donne le nombre de digit qui doivent apparaitre
					 Si la valeur converti necessite plus de digit elle est rempli avec des 0 a gauche.
Convertion "u"		: Converti unsigned int en unsigned decimal.


PARSING :
%[drapeaux][gabarit][.précision][modificateur]spécificateur
Prend un pointeur sur char;
increment et passe le "%"
On check si on a un nombre
	-> On lit le nombre depuis la chaine (atoi ?).
		-> Si le char apres est un $ on update la struct avec le num d'arg si
le num darg nexiste pas on mets -1.
		-> Si le nombre dapres nest pas un $, cest la taille du champ ou le 0 padding
		on remet la chaine au debut.
On check les flag -> Si ce sont des flag avec 0/- attention il faut regarder la
valeur dapres pour avoir le nombre de digit sur lequel l'ecrire
Si on trouve un '.' -> on soccupe de la precision. On lit juska que ce soir de nouveux des lettres
On gere les modificateur, et ensuite le specificateur.
